<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>録音アプリ</title>
    <style>
        body { font-family: Arial, sans-serif; background: #f5f5f5; margin: 20px; }
        h1 { text-align: center; }
        button { margin: 5px; padding: 8px 12px; cursor: pointer; }
        #controls { display: flex; justify-content: center; margin-bottom: 10px; }
        #recordings { margin-top: 15px; }
        .record-item { border: 1px solid #ccc; padding: 10px; margin: 10px 0; background: white; border-radius: 8px; }
        audio { display: block; margin-top: 5px; }
        .toolbar { display: flex; justify-content: center; margin-bottom: 15px; gap: 10px; }
    </style>
</head>
<body>
    <h1>🎤 録音アプリ</h1>

    <div id="controls">
        <button id="startBtn">録音開始</button>
        <button id="stopBtn" disabled>録音停止</button>
        <select id="sortSelect">
            <option value="newest">新しい順</option>
            <option value="oldest">古い順</option>
            <option value="longest">長い順</option>
            <option value="shortest">短い順</option>
        </select>
    </div>

    <div style="text-align: center; margin-bottom: 10px;">
    <input type="text" id="searchInput" placeholder="🔍 キーワード検索（タイトル・日付・文字起こし）" style="width: 80%; padding: 8px;">
</div>

    <div class="toolbar">
        <button id="deleteSelectedBtn">選択削除</button>
        <button id="deleteAllBtn">全部削除</button>
        <button id="downloadSelectedBtn">選択ダウンロード</button>
        <button id="downloadAllBtn">全部ダウンロード</button>
        <button id="unselectAllBtn">選択全部解除</button>
    </div>

    <p id="liveText">ここに録音中の文字が表示されます...</p>
    <p id="recordingStatus" style="color: red; font-weight: bold; display: none;">🎙️ 録音中...</p>
    <div id="recordings"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>

    <script>

    function normalizeText(text) {
        return (text || "")
            .toLowerCase()
            .replace(/\s+/g, "") // 空白を削除
            .replace(/[ぁ-ん]/g, ch =>
                String.fromCharCode(ch.charCodeAt(0) + 0x60) // ひらがな→カタカナ
            )
            .replace(/[ー－―]/g, "") // 長音を削除
            .normalize("NFKC"); // 全角→半角、濁点などの正規化
    }

        const recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
        recognition.lang = 'ja-JP';
        recognition.interimResults = true;
        recognition.continuous = true;

        let isRecording = false;
        let finalTranscript = "";
        let tempTranscript = "";
        let mediaRecorder;
        let audioChunks = [];
        let recordings = JSON.parse(localStorage.getItem("recordings") || "[]");

        // 録音番号を過去データから計算
        let recordingCount = recordings.length > 0
            ? Math.max(...recordings.map(r => parseInt(r.title.replace("録音 ", ""))))
            : 0;

        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const liveText = document.getElementById('liveText');
        const recordingsDiv = document.getElementById('recordings');
        const sortSelect = document.getElementById('sortSelect');
        const deleteSelectedBtn = document.getElementById('deleteSelectedBtn');
        const deleteAllBtn = document.getElementById('deleteAllBtn');
        const downloadSelectedBtn = document.getElementById('downloadSelectedBtn');
        const downloadAllBtn = document.getElementById('downloadAllBtn');

        async function initRecorder() {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorder = new MediaRecorder(stream);

            mediaRecorder.ondataavailable = (e) => {
                audioChunks.push(e.data);
            };

            mediaRecorder.onstop = async () => {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                const audioURL = URL.createObjectURL(audioBlob);

                const title = `録音 ${++recordingCount}`;
                const date = new Date().toLocaleString("ja-JP", {
                    year: "numeric", month: "long", day: "numeric",
                    hour: "2-digit", minute: "2-digit"
                });

                const newRecording = {
                    id: Date.now(),
                    title,
                    audioURL,
                    transcript: finalTranscript || tempTranscript || "（文字なし）",
                    date,
                    duration: Math.round(audioBlob.size / 16000)
                };

                recordings.push(newRecording);
                localStorage.setItem("recordings", JSON.stringify(recordings));

                audioChunks = [];
                finalTranscript = "";
                tempTranscript = "";
                liveText.textContent = "ここに録音中の文字が表示されます...";

                renderRecordings();
            };
        }

        initRecorder();

        startBtn.addEventListener('click', () => {
            if (mediaRecorder && mediaRecorder.state === "inactive") {
                mediaRecorder.start();
            }

            isRecording = true;
            finalTranscript = "";
            tempTranscript = "";
            recognition.start();
            startBtn.disabled = true;
            stopBtn.disabled = false;

            // 録音中の表示
            const recordingStatus = document.getElementById('recordingStatus');
            recordingStatus.textContent = "🎙️ 録音中...";
            recordingStatus.style.color = "red";
            recordingStatus.style.display = "block";
        });

        stopBtn.addEventListener('click', () => {
          //最後のリアルタイム文字を保存してから録音停止
finalTranscript += tempTranscript;
          tempTranscript = "";

            if (mediaRecorder && mediaRecorder.state === "recording") {
                mediaRecorder.stop();
            }
            isRecording = false;
            // 音声認識を停止してリアルタイム文字起こしを強制クリア
               recognition.stop();
             liveText.textContent = "ここに録音中の文字が表示されます...";
            startBtn.disabled = false;
            stopBtn.disabled = true;

            const recordingStatus = document.getElementById('recordingStatus');
recordingStatus.style.display = "none";

            // リアルタイムの途中経過テキストを消す
              tempTranscript = "";
              liveText.textContent = "ここに録音中の文字が表示されます...";

        });

        recognition.addEventListener('result', (event) => {
            tempTranscript = "";
            for (let i = event.resultIndex; i < event.results.length; i++) {
                const result = event.results[i];
                if (result.isFinal) {
                    finalTranscript += result[0].transcript;
                } else {
                    tempTranscript = result[0].transcript;
                }
            }
            liveText.textContent = finalTranscript + tempTranscript;
        });

        recognition.addEventListener('end', () => {
            if (isRecording) {recognition.start();

          } else {
                // 録音停止時は必ずリアルタイム文字をクリア
                tempTranscript = "";
                liveText.textContent = "ここに録音中の文字が表示されます...";
                // -------------------
            }

        });

        function renderRecordings() {
            recordingsDiv.innerHTML = "";

            const keyword = normalizeText(searchInput.value);

               let filteredRecordings = recordings.filter(rec => {
                   const title = normalizeText(rec.title || "");
                   const date = normalizeText(rec.date || "");
                   const transcript = normalizeText(rec.transcript || "");

                   return (
                       title.includes(keyword) ||
                       date.includes(keyword) ||
                       transcript.includes(keyword)
                   );

            });
            let sorted = [...filteredRecordings];

            switch (sortSelect.value) {
                case "newest": sorted.sort((a, b) => b.id - a.id); break;
                case "oldest": sorted.sort((a, b) => a.id - b.id); break;
                case "longest": sorted.sort((a, b) => b.duration - a.duration); break;
                case "shortest": sorted.sort((a, b) => a.duration - b.duration); break;
            }

            sorted.forEach((rec) => {
                const recordItem = document.createElement('div');
                recordItem.className = 'record-item';

                recordItem.innerHTML = `
                    <input type="checkbox" class="selectRecording" data-id="${rec.id}">
                    <input type="text" class="editTitle" data-id="${rec.id}" value="${rec.title}" />
                    <p>（${rec.date}）</p>
                    <audio controls src="${rec.audioURL}"></audio>
                    <p>⏱ 長さ: ${rec.duration}秒</p>
                    <p>📝 <strong>文字起こし:</strong><br>${rec.transcript || "（文字なし）"}</p>
                `;

                recordingsDiv.appendChild(recordItem);
            });

            document.querySelectorAll('.editTitle').forEach(input => {
                input.addEventListener('input', (e) => {
                    const id = Number(e.target.dataset.id);
                    const newTitle = e.target.value;
                    const recIndex = recordings.findIndex(r => r.id === id);
                    if (recIndex !== -1) {
                        recordings[recIndex].title = newTitle;
                        localStorage.setItem("recordings", JSON.stringify(recordings));
                    }
                });
            });
        }

        // 録音データをBlobとして取得
        async function fetchAudioBlob(url) {
            const res = await fetch(url);
            return await res.blob();
        }

        const unselectAllBtn = document.getElementById('unselectAllBtn');

unselectAllBtn.addEventListener('click', () => {
    document.querySelectorAll('.selectRecording').forEach(checkbox => {
        checkbox.checked = false;
    });
});

        // 選択した録音を削除
        deleteSelectedBtn.addEventListener('click', () => {
            const selected = Array.from(document.querySelectorAll('.selectRecording:checked'))
                .map(checkbox => Number(checkbox.dataset.id));

            recordings = recordings.filter(rec => !selected.includes(rec.id));
            localStorage.setItem("recordings", JSON.stringify(recordings));
            renderRecordings();
        });

        // 全部削除
        deleteAllBtn.addEventListener('click', () => {
            if (confirm("本当に全部削除しますか？")) {
                recordings = [];
                localStorage.removeItem("recordings");
                recordingCount = 0;
                renderRecordings();
            }
        });

        // 選択した録音をダウンロード
        downloadSelectedBtn.addEventListener('click', async () => {
            const selected = Array.from(document.querySelectorAll('.selectRecording:checked'))
                .map(checkbox => Number(checkbox.dataset.id));

            if (selected.length === 0) {
                alert("録音を選択してください！");
                return;
            }

            const zip = new JSZip();
            for (const rec of recordings.filter(r => selected.includes(r.id))) {
                const blob = await fetchAudioBlob(rec.audioURL);
                zip.file(`${rec.title}.webm`, blob);
            }

            const content = await zip.generateAsync({ type: "blob" });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(content);
            link.download = "選択した録音.zip";
            link.click();
        });

        // 全部ダウンロード
        downloadAllBtn.addEventListener('click', async () => {
            if (recordings.length === 0) {
                alert("録音がありません！");
                return;
            }

            const zip = new JSZip();
            for (const rec of recordings) {
                const blob = await fetchAudioBlob(rec.audioURL);
                zip.file(`${rec.title}.webm`, blob);
            }

            const content = await zip.generateAsync({ type: "blob" });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(content);
            link.download = "全部の録音.zip";
            link.click();
        });

        sortSelect.addEventListener('change', renderRecordings);

        const searchInput = document.getElementById("searchInput");
        searchInput.addEventListener("input", () => {
            renderRecordings();
        });

        renderRecordings();
    </script>
</body>
</html>
